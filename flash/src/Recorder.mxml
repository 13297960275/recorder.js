<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" initialize="app_initializeHandler(event)" width="155" height="124" alpha="0" usePreloader="false" error="app_errorHandler(event)">

	<fx:Script>
		<![CDATA[
			import com.adobe.audio.format.WAVWriter;
			import com.adobe.serialization.json.JSON;
			
			import flash.events.ErrorEvent;
			import flash.events.SampleDataEvent;
			import flash.external.ExternalInterface;
			import flash.media.Microphone;
			import flash.media.Sound;
			import flash.media.SoundChannel;
			import flash.system.Capabilities;
			import flash.utils.ByteArray;
			
			import mx.collections.ArrayCollection;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.events.FlexEvent;
			
			import ru.inspirit.net.MultipartURLLoader;
			
			protected var isRecording:Boolean = false;
			protected var isPlaying:Boolean = false;
			protected var microphoneWasMuted:Boolean;
			protected var playingProgressTimer:Timer;
			protected var microphone:Microphone;
			protected var buffer:ByteArray;
			protected var sound:Sound;
			protected var channel:SoundChannel;
			protected var _debugLog:Array = new Array();
			protected static var sampleRate = 44.1;
			
			// These statics are used for a special SoundCloud build of the recorder
			// that allows to use connect.soundcloud.com/recorder.swf from any domain
			// and provides a request method that allows cross domain ajax requests.

			protected static var enableCrossDomainAccess 		  = true;
			protected static var exposeCrossDomainRequestFunction = true;			
			
			protected function app_initializeHandler(event:FlexEvent):void
			{	
				if(enableCrossDomainAccess){
					Security.allowDomain("*");
				}
				if (ExternalInterface.available) {
					ExternalInterface.addCallback("record", 		record);
					ExternalInterface.addCallback("stop",     		stop);
					ExternalInterface.addCallback("play",           play);
					ExternalInterface.addCallback("upload",         upload);
					ExternalInterface.addCallback("audioData",      audioData);
					ExternalInterface.addCallback("showFlash",      showFlash);
					ExternalInterface.addCallback("debugLog",       debugLog);
					ExternalInterface.addCallback("raiseError",     raiseError);
					if(exposeCrossDomainRequestFunction){
						ExternalInterface.addCallback("request",        request);
					}
					debug('ExternalInterface ready');
					try{
						triggerEvent('initialized', {});
					}catch(e:Error){
						debug(e.message + "\n" + e.getStaceTrace());
					}
				}else{
					debug('ExternalInterface NOT available');
				}

			}
			
			protected function app_errorHandler(event:ErrorEvent):void
			{
				debug("Error: " + event.toString());
			}
			
			/* Available via external interface */
			
			protected function record():void
			{
				if(!microphone){ 
					setupMicrophone();
				}
				
				if(!microphone.muted){
					notifyRecordingStarted();
				}			
				
				buffer = new ByteArray();
				microphone.addEventListener(SampleDataEvent.SAMPLE_DATA, recordSampleDataHandler);
			}
			
			protected function recordStop():int
			{
				debug('stopRecording');
				isRecording = false;
				triggerEvent('recordingStop', {duration: recordingDuration()});
				microphone.removeEventListener(SampleDataEvent.SAMPLE_DATA, recordSampleDataHandler);
				return recordingDuration();
			}
			
			protected function play():void
			{
				debug('startPlaying');
				isPlaying = true;
				triggerEvent('playingStart', {});
				buffer.position = 0;
				sound = new Sound();
				sound.addEventListener(SampleDataEvent.SAMPLE_DATA, playSampleDataHandler);

				channel = sound.play();
				channel.addEventListener(Event.SOUND_COMPLETE, function(){
					playStop();
				});  
				
				if(playingProgressTimer){
					playingProgressTimer.reset();
				}
				playingProgressTimer = new Timer(50);
				playingProgressTimer.addEventListener(TimerEvent.TIMER, function playingProgressTimerHandler(event:TimerEvent){
					triggerEvent('playingProgress', int(channel.position));
				});
				playingProgressTimer.start();
			}
			
			protected function stop():int
			{
				playStop();
				return recordStop();
			}

			protected function playStop():void
			{
				debug('stopPlaying');
				if(channel){
					channel.stop();
					playingProgressTimer.reset();

					triggerEvent('playingStop', {});
					isPlaying = false;
				}
			}
		
			/* Networking functions */ 
			
			protected function upload(uri:String, audioParam:String, parameters:Object): void
			{
				debug("upload");
				buffer.position = 0;
				var wav:ByteArray = prepareWav();					
				var ml:MultipartURLLoader = new MultipartURLLoader();
				ml.addEventListener(Event.COMPLETE, onReady);
				function onReady(e:Event):void
				{
					triggerEvent('uploadSuccess', e.target.loader.data);
					debug('uploading done');
				}
				
				for(var k in parameters){
					ml.addVariable(k, parameters[k]);		
				}
				
				ml.addFile(wav, 'audio.wav', audioParam);
				ml.load(uri, false);
				
			}
			
			protected function request(method:String, url:String, data:String, callbackName:String):void
			{
				var request:URLRequest = new URLRequest(url);
				request.method = method;
				request.requestHeaders = new Array(new URLRequestHeader("Content-Type", "application/x-www-form-urlencoded"));

				// workaround to not ignore method when body is blank
				// see http://forums.adobe.com/thread/746809?decorator=print&displayFullThread=true
				if(data == null || data == ""){
					data = " ";
				}

				request.data = data;
				
				var _subLoader = new URLLoader();
				var callback = function(e:Event){
					ExternalInterface.call("Recorder.triggerCallback", callbackName, [e.target["data"], e.target]);
				}
					
				_subLoader.addEventListener( Event.COMPLETE, callback);				
				_subLoader.addEventListener(IOErrorEvent.IO_ERROR, callback);
				_subLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, callback);
				_subLoader.dataFormat = URLLoaderDataFormat.TEXT;
				_subLoader.load( request );
			}
			
			
			protected function audioData():String
			{
				var ret:String="";
				buffer.position = 0;				
				while (buffer.bytesAvailable > 0) 
				{
					ret += buffer.readFloat().toString() + ";";
				}
				return ret;
			}
			
			protected function showFlash():void
			{
				Security.showSettings();
				triggerEvent('showFlash','');	
			}
			
			/* Recording Helper */ 
			protected function setupMicrophone():void
			{
				debug('setupMicrophone');
				microphone = Microphone.getMicrophone();
				microphone.setSilenceLevel(0);
				microphone.rate = sampleRate;
				microphone.gain = 50;
				microphone.addEventListener(StatusEvent.STATUS, function statusHandler(e:Event) {
					debug('Microphone Status Change');
					if(!microphone.muted && !isRecording){
						notifyRecordingStarted();
					}
				});
				
				microphoneWasMuted = microphone.muted;
				if(microphoneWasMuted){
					debug('showFlashRequired');
					Security.showSettings(SecurityPanel.MICROPHONE);
					triggerEvent('showFlash','');
				} 
				
				debug('setupMicrophone done: ' + microphone.name + ' ' + microphone.muted);
			}
			
			protected function notifyRecordingStarted():void
			{
				if(microphoneWasMuted){
					microphoneWasMuted = false;
					triggerEvent('hideFlash','');
				}
				triggerEvent('recordingStart', {});
				debug('startRecording');
				isRecording = true;
			}
			
			/* Sample related */
			
			protected function prepareWav():ByteArray
			{
				var wavData:ByteArray = new ByteArray();
				var wavWriter:WAVWriter = new WAVWriter(); 
				buffer.position = 0;
				wavWriter.numOfChannels = 1; // set the inital properties of the Wave Writer 
				wavWriter.sampleBitRate = 16; 
				wavWriter.samplingRate = sampleRate * 1000;
				wavWriter.processSamples(wavData, buffer, sampleRate * 1000, 1);
				return wavData;
			}
			
			protected function recordingDuration():int
			{
				var floatByteSize = 4;
				return int(buffer.length / sampleRate / floatByteSize)
			}
			
			protected function recordSampleDataHandler(event:SampleDataEvent):void
			{	
				while(event.data.bytesAvailable)
				{	
					var sample:Number = event.data.readFloat();

					buffer.writeFloat(sample);
					if(buffer.length % 10000 == 0){
						debug(buffer.length.toString());

						triggerEvent('recordingProgress', recordingDuration(), 	microphone.activityLevel);
					}	
				}
			}
					
			protected function playSampleDataHandler(event:SampleDataEvent):void
			{				
				for (var i:int = 0; i < 8192 && buffer.bytesAvailable; i++)
				{
					var sample:Number = buffer.readFloat();
					event.data.writeFloat(sample); 
					event.data.writeFloat(sample);  
				}
			}
			
			/* ExternalInterface Communication */
			
			protected function triggerEvent(eventName:String, arg0, arg1 = null):void
			{	
				debug("triggerEvent(" + eventName + "," + arg0.toString());
				ExternalInterface.call("Recorder.triggerEvent", eventName, arg0, arg1);
			}
			
			/* DEBUGGING METHODS */
			
			protected function debug(message:String):void
			{
				//triggerEvent('debug', {message: message});
				_debugLog.push(message);
			}
			
			protected function debugLog():Array
			{
				return _debugLog;
			}
			
			protected function raiseError():void
			{
				debug("prepare  for raise");
				throw new Error("raiseError fake exception");
				debug("done");
			}
			

		]]>
	</fx:Script>
</s:Application>
